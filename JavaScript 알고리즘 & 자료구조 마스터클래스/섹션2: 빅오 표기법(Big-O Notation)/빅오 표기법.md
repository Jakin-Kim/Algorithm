# 빅오 표기법(Big-O Notation)

## 1) 빅오 표기법이란?

- 알고리즘의 시간복잡도(time-complexity)와 공간복잡도(space-complexity)에 따른 실행시간을 표기하는 방법이다.
- Big-O Notation is a way to formalize fuzzy counting. It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow.

## 2) 사용하는 이유

- 코드가 어떻게 동작하는지에 대해 정확한 용어로 설명할 수 있기 때문이다.
- 같은 코드라도 다른 접근법이 있으며, 효율성(시간복잡도나 공간복잡도)이(가) 다르기 때문이다.
    - 만약 `n`까지 더한 값을 반환하는 함수를 만들어야 한다면?
        - 예시1 → much slower
            - 연산속도:
            - 연산횟수: $(3n+1)^2$회 ⇒ `O(n^2)`
            ```jsx
            function printAllPairs(n) {
                for(let i = 0; i < n; i++) {
                    for(let j = 0; j < n; j++) {
                        console.log(i, j);
                    }
                }
            }
            ```
            
        - 예시2 → slower
            - 연산속도: 1.2XXX seconds
            - 연산횟수: (5n + 2)회 ⇒ `O(n)`
            ```jsx
            function addUpTo(n) {
              let total = 0;
              for (let i = 1; i <= n; i++) { // n에 따라 반복되는 횟수만큼 =, + 연산자가 사용된다.
                total += i;
              }
              return total;
            }
            
            var t1 = performance.now();
            addUpTo(1000000000);
            var t2 = performance.now();
            console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`) // 1.2XXX seconds
            ```
            ```jsx
            function countUpAndDown(n) {
            	console.log('Going up!');
            	for(let i = 0; i < n; i++) {
            		console.log(i);
            	}
            	console.log('At the top!\n Going down...');
            	for(let j = n - 1; j >= 0; j--) {
            		console.log(j);
            	}
            	console.log('Back down. Bye!');
            }
            ```
        - 예시3 → faster
            - 연산속도: 0.00001 seconds
            - 연산횟수: 3회 ⇒ `O(1)`
            ```jsx
            function addUpTo(n) {
              return n * (n + 1) / 2; // *, +, / 연산 뿐이기 때문에 n이 얼마든지 상관없이 3번만 연산한다.
            }

            var time1 = performance.now();
            addUpTo(1000000000);
            var time2 = performance.now();
            console.log(`Time Elapsed: ${(time2 - time1) / 1000} seconds.`) // 0.000001 seconds
            ```
