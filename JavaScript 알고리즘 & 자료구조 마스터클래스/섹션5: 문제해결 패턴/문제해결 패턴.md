# 1. 문제 해결 패턴(해결 방법을 아는 경우)

## 2) **일반적인 문제해결 패턴을 파악한다(Master common problem solving patterns).**

- 여러 패턴의 문제유형(프로그래밍 매커니즘)
    1. Frequency Counter
    2. Multiple Pointers
    3. Sliding Window
    4. Divide and Conquer
    5. Dynamic Programming
    6. Greedy Algorithms
    7. Backtracking
    8. and so on

### (1) 빈도 카운터(Frequency Counter)

1. 왜 빈도카운터인가?
    - 여러 데이터와 입력값이 서로 비슷한 값으로 구성되어 있는지, 서로 간의 아나그램인지, 값이 다른 값에 포함되는지 여부를 비교하거나, 데이터를 입력값이나 두 개 이상의 빈도 혹은 특정하게 발생하는 빈도와 비교할 때 유용하기 때문이다.
2. 주로 언제 사용하는가?
    - 중첩반복문이 사용되는 경우 사용한다.
    
    ```jsx
    // ex
    // Write a function called 'same', which accepts two arrays.
    // The function should return true if every value in the array has
    // it's corresponding value squared in the second array.
    // The frequency of values must be the same.
    
    **// solution1. -> O(N^2)**
    function same(arr1, arr2) {
    	// 각 배열의 요소의 갯수가 다르다면 살펴볼 필요도 없이 false이다.
    	if(arr1.length !== arr2.length) return false;
    
    	// sort()는 O(N*logN)이고 중첩반복문은 O(N^2)이기 때문에 최대한 사용하지 않기.
    	let squaredArr1 = []; // arr1의 모든 요소가 제곱된 배열을 만든다.
    	let count = 0;	// 배열의 길이와 동일하며 각 요소가 동일한지 여부를 카운트하는 변수 선언하기
    	
    	for(let ele of arr1) {
    		ele *= ele;
    		if(arr2.includes(ele)) count++;
    		squaredArr1.push(ele);
    	}
    
    	if(arr2.length === count) {
    		return true;
    	} else {
    		return false;
    	}
    }
    
    **// solution2. -> O(N^2)**
    function same(arr1, arr2) {
    	if(arr1.length !== arr2.length) return false;
    
    	for(let i = 0; i < arr1.length; i++) {
    		let correctIdx = arr2.indexOf(arr1[i] ** 2);
    		if(correctIdx === -1) return false;
    		arr2.splice(correctIdx, 1);
    	}
    	return true;
    }
    ```
    
    - 중첩반복문을 사용하지 않는(빅오 표기법을 고려하면 효율적인) 해결책이다.
    
    ```jsx
    **// Refactored solution3. -> O(N)**
    
    function same(arr1, arr2) { // [1,4,4,9], [81,16,16,1]
    	if(arr1.length !== arr2.length) return false;
    
    	// 두 객체를 사용해서 각 배열의 개별 값의 빈도를 개수하도록 한다.
    	let frequencyCnt1 = {};
    	let frequencyCnt2 = {};
    	for(let val of arr1) {
    		frequencyCnt1[val] = (frequencyCnt1[val] || 0) + 1;
    	}
    	for(let val of arr2) {
    		frequencyCnt2[val] = (frequencyCnt2[val] || 0) + 1;
    	}
    
    	// 만든 두 객체 중에 어떤 것을 loop하든지 상관없다.
    	for(let key in frequencyCnt1) {
    		if(!(key ** 2 in frequencyCnt1)) return false;
    		if(frequencyCnt2[key ** 2] !== frequencyCnt1[key]) return false;
    	}
    	return true;
    }
    ```
